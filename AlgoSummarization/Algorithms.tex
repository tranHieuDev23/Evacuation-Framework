\documentclass{article}
\usepackage[utf8]{vietnam}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{geometry}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\geometry{
		top = 35mm,
		left = 40mm,
		right = 30mm,
		bottom = 40mm
}

\begin{document}

\textsc{\LARGE Đại Học Bách Khoa Hà Nội} \\[1,5cm]
\textsc{\large Lớp Kĩ Sư Tài Năng - Công Nghệ Thông Tin K62} \\[0.5cm]
{\huge\bfseries Tìm đường thoát hiểm }\\[0.4cm] 

    \begin{flushleft}
        \large
        Ngày 8 tháng 5 năm 2019 \\[0.5cm]
        \textit{Author}\\[0,3cm]
           
    \end{flushleft}
    
    \section{Tiêu chuẩn đề đánh giá trọng số con đường}
    Xét đoạn đường với chiều dài L, chiều ngang H, chỉ số an toàn T,
    và hiện tại có N người trên đoạn đường đó. Giả sử trong điều 
    kiện bình thường, đoạn đường không có người, độ an toàn T = 1, 
    thì với một người di chuyển vào con đường đó sẽ có vận tốc là V.
    Nhưng với ngoại cảnh cụ thể, thì vận tốc người đó sẽ nhỏ hơn,
    có thể coi như vận tốc thực tế của người đó tỉ lệ thuận với độ 
    an toàn và tỉ lệ nghịch với mật độ người trên con đường đó.
    Ta có thể xét 
    \begin{equation*}
        \emph{v} = \frac{V*f(T)}{g(D)}
    \end{equation*}
    $D = \frac{L*H}{X*Y}$ là mật độ người trên đoạn đường,
    g và f là hai hàm đồng biến trên khoảng giá trị tương ứng
    với D và T.
    Như vậy, thời gian để những người đó đi hết đoạn đường là:
    \begin{displaymath}
        t = \frac{L}{\emph{v}}  
        \Leftrightarrow t = \frac{L*g(D)}{V*f(T)}   
    \end{displaymath}
    Đặt trọng số $w = \frac{L*g(D)}{f(T)}$ thì $t = \frac{w}{V}$. \\
    Như vậy, trong công thức trên, nếu V là vận tốc chuẩn của một 
    người thì w giống như chuẩn độ dài của con đường trong ngoại 
    cảnh cụ thể, và thời gian đi qua con đường sẽ được tính bởi 
    hai đơn vị trên. \\
    Ta sẽ giả sử tất cả mọi người trong tòa nhà đều có cùng vận tốc
    trung bình là $v_{tb}$, và khi đó thì để so sánh xem hai con
    đường nào tốt hơn, tức là ta phải so sánh thời gian thoát hiểm 
    của hai con đường đó, đồng nghĩa với việc ta phải so sánh trọng 
    số w của quãng đường. \\ 
    Ở đây, ta sẽ sử dụng hàm 
    \begin{equation}
        f(T) = T, g(D) = D + 1
    \end{equation}
    
    \section{Ý tưởng thuật toán}
    Xét đoạn đường đi từ một Indicator u trong tòa nhà tới một exit 
    node e, gồm các corridor theo thứ tự là $p = <p_{1}, p_{2}, ...,p_{k}
    >$. Với mỗi corridor $p_{i}$ sẽ có tương ững $n_{i}$ người. \\ 
    Trong số w của đoạn đường được tính: $w = \sum{w_{i}}$ với 
    $w_{i} \frac{L_{i}*g(D_{i})}{f(T_{i})}$ là trọng số của quãng 
    đường tương ứng tại thời điểm hiện tại. Với công thức như trên 
    thì ta thấy trọng số của đường đi từ Indicator u sẽ phụ thuộc vào lượng
    người trên mỗi cạnh tại thời điểm tính, là $t_{0}$. Tại thời điểm
    $t_{1}$ những người ở cạnh $p_{1}$ đi đến được $p_{i}$, lúc đó 
    lượng người trên cạnh $p_{i}$ đã thay đổi.
    Ta có nhận xét rằng khi mà nhóm người A ở cạnh $p_{i1}$ tới 
    được được cạnh $p_{i2}$ (i2 > i1) thì những người ở cạnh 
    $p_{i2}$ đã do chuyển sang cạnh khác, tức là họ không ảnh hưởng 
    tới thời gian di chuyển của nhóm người A trên cạnh $p_{i2}$ 
    Như vậy, nếu ta muốn 
    lấy trọng số w để đặc trưng cho thời gian thoát hiểm của một
    nhóm người trên một đoạn đường thì không thể tính bởi công thức 
    như trên. Để có thể tính chi li, xét dãy $t = <t_{1}, t_{2},
    ..., t_{k}>$, $t_{i}$ là thời điểm mà số người đó bắt đầu đi vào
    quãng đường $p_{i}$, thì trọng số w sẽ được tính 
    \begin{equation}
        w = \sum{w_{i}}
    \end{equation}  
    với $w_{i}$ là trọng số của quãng đường $p_{i}$ tại thời điểm 
    $t_{i}$. \\
    Vấn đề là với mỗi đường đi khác nhau sẽ có cách chia thời gian 
    khác nhau, và để tính toán với từng đoạn đường như vậy là không 
    thể về khía cạnh thời gian tính toán. \\ 
    Với ý tưởng tương tự trên, ta sẽ chia đường đi làm 2 phần. 
    Phần đầu tiên là quãng đường đi được trong t(s) tiếp theo, 
    phần tiếp theo là đoạn còn lại. Giả sử trong t(s) tiếp theo 
    thì những người ở Indicator u đi đến được đoạn $p_{i}$. \\
    Đặt path1 = $<p_{1}, ..., p_{i-1}$, path2 = $<p_{i}, ..., p_{k}
    >$. Trọng số của đoạn đường p sẽ được tính: 
    \begin{equation}
        w = w1 + w2 
    \end{equation}
    với \begin{itemize}
        \item $w1 = \sum{w_{j}}, j < i$, các đoạn $w_{j}$ được
        tính với số người trên đoạn là $n_{1}$ người, hay là số 
        người đang ở $p_{1}$ tại thời điểm hiện tại.
        \item $w2 = \sum{w_{j}}, i <= j <= k$, các đoạn $w_{j}$
        được tính với số người tới được $p_{i}$ trong t giây 
        tiếp theo.
    \end{itemize}
    \section{Nội dung thuật toán}
    \newpage
    Thuật toán nhận đầu vào là một đồ thì gồm đỉnh và các cạnh có thông tin
    đi kềm, thực hiện nhiệm vụ là chỉ đường đi cho tất cả các đỉnh trong đồ
    thị. Dưới đây là các đặc tính của lớp Node và Edge. \\ 
    \textbf{Node}: 
    \begin{itemize}
        \item \textit{next}: đỉnh được lựa chọn là hướng đi đến.
        \item \textit{nextEdge}: cạnh được lựa chọn là hướng đi đến.
        \item \textit{adjacences}: Danh sách struct gồm có:
        \begin{itemize}
            \item \textit{node}: đỉnh kề
            \item \textit{edge}: cạnh kề
            \item \textit{passingWeight}: trọng số của path mà đi qua đỉnh kề 
            \item \textit{reaching}: đỉnh tới được sau t(s) mà đi qua đỉnh 
            kề
        \end{itemize}    
        \item \textit{weight}: trọng số của đường đi tới root.
        \item \textit{nComingPeople}: số người sẽ đến sau t(s).
        \item \textit{tReachedNode}: đỉnh sẽ tới được sau t(s).
        \item \textit{tComingNodes}: danh sách đỉnh tới được sau t(s).
        \item \textit{label}: nhãn của đỉnh.
    \end{itemize}
    \textbf{Edge}
    \begin{itemize}
        \item \textit{to}: đỉnh tới.
        \item \textit{Length, Width, Trustness}: các thông số.
        \item \textit{nPeople}: số người trên cạnh.
        \item \textit{density}: mật độ.
        \item \textit{weight}: trọng số của cạnh.
    \end{itemize}
    \begin{algorithm}
    \caption{Algorithm caption}
    \label{alg:algorithm-label}
    \textbf{Input:} Đồ thị có trọng số ứng với các Indicator và Node\\
    \textbf{Output:} Đường đi ngắn nhất từ root đến mọi đỉnh trong đồ thị\\
    heap: cấu trúc heap min với phần tử là các đỉnh và so sánh dựa 
    trên weight.
    \begin{algorithmic}[1]
        \em
    \Procedure{Main Algorithm}{}
        \State heap.push(root)
        \State root.label $\gets$ true
        \While{$heap.size > 0$}
        \State $u \gets heap.pop()$
        \State u.label = true
        \State s $\gets$ u.tReachedNode
        \State s.nComingPeople $\gets$ s.nComingPeople + u.nextEdge.nPeople
        \State s.tComingNodes $\gets$ u
        \State \textbf{UpdateComingNode}(s)
        \For{v \textbf{in} u.adjacences \textbf{and} v.node.label = true}
        \State \textbf{UpdateComingPeople}(v.edge)
        \EndFor
        \For{v \textbf{in} u.adjacences \textbf{and} v.node.label = false} 
        \State s = \textbf{FindCrossNode}(v.node, v.edge)
        \State s.nComingPeople $\gets$ s.nComingPeople + v.edge.nPeople
        \State w1 $\gets$ \textbf{CalculateWeight}(u, s, v.edge.nPeople)
        \State w2 $\gets$ \textbf{CalculateWeight}(s, root, s.nComingPeople)
        \State newW $\gets$ v.edge.weight + w1 + w2
        \State ad \textbf{in} v.node.adjacences \textbf{which} ad.node = u
        \State ad.edgeWeight $\gets$ newW
        \State ad.reachedNode $\gets$ s
        \If{newW < v.node.weight}
        \State v.node.weight $\gets$ newW
        \State v.node.next $\gets$ u 
        \State v.node.tReachedNode $\gets$ s
        \State heap.push(v.node)
        \EndIf
        \State \textbf{end if}
        \State s.nComingPeople $\gets$ s.nComingPeople - E[v.node,u].nPeople
        \EndFor
        \textbf{end for}
        \EndWhile
        \textbf{end while}
    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{UpdateComingPeople}
        \textbf{Input}:Edge edge, Node node \\ 
        Cạnh nằm giữa hai đỉnh đã được gán nhãn và chưa được cập nhật. \\
        \textbf{Output:}: Cập nhật số người ở cạnh đó cho đỉnh nó tới được sau t(s)

        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \em
            \State s $\gets$ \textbf{FindCrossNode}(node, edge)
            \State s.nComingPeople $\gets$ s.nComingPeople + edge.nPeople
            \State \textbf{UpdateComingNode}(s)
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
    
    \begin{algorithm}
        \caption{FindCrossNode}
        \textbf{Input}: \textit{Node} node, \textit{Edge} edge\\
        \textbf{Output}: Trả lại đỉnh xa nhất trên đường đi ngắn nhất của u mà v 
        đi tới được trong thời gian t.
        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \em
            \State sumWeight $\gets$ $v_{tb}*t$ 
            \State nPeople $\gets$ edge.nPeople
            \State from $\gets$ node
            \While{sumWeight > 0}
            \State sumWeight $\gets$ sumWeight - \textbf{GetWeight}(edge, nPeople)
            \State from $\gets$ edge.to
            \State edge $\gets$ from.nextEdge
            \If{from = root} break
            \EndIf
            \EndWhile 
            \textbf{end while} \\
            \Return from
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{CalculateWeight}
        \textbf{Input}: \textit{Node} u, \textit{Node} s, int nPeople \\
        \textbf{Output}: Trả lại trọng số của quãng đường đi từ u tới s với 
        nPeople người đi.
        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \em
            \State weight $\gets$ 0
            \While{u \textbf{!=} s}
            \State edge $\gets$ u.nextEdge
            \State u $\gets$ u.next
            \State density $\gets$ \textbf{GetDensity}(edge, nPeople)
            \State weight $\gets$ weight + L * \textbf{F}(edge.Trustness, density)
            \EndWhile
            \Return weight
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{UpdateComingNode}
        \textbf{Input}: \textit{Node} s \\ 
        \textbf{Output}: Cập nhật lại trọng số của các Node mà sẽ tới được s
        trong thời gian t những vẫn chưa được gán nhãn.
        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \For{u \textbf{in} s.tComingNodes \textbf{and} u.label = false}
            \State v \textbf{in} u.adjacences \textbf{which} v.reaching = s
            \State w1 $\gets$ \textbf{CalculateWeight}(v.node, s, v.edge.nPeople)
            \State w2 $\gets$ \textbf{CalculateWeight}(s, root, s.nComingPeople)
            \State v.passingWeight $\gets$ v.edge.weight + w1 + w2
            \State \textbf{GetNextNode}(u)
            \State heap.Rebuild(u)
            \EndFor
            \textbf{end for}
            \EndProcedure

            \Procedure{GetNextNode}{u}
            \Comment{Đặt lại đỉnh kề tốt nhất cho u}
            \For{v \textbf{in} u.adjacences \textbf{and} v.node.label = true}
            \If{v.edgeWeight < u.weight}
            \State u.weight = v.edgeWeight
            \State u.next = v.node
            \State u.tReachedNode = v.reachedNode \\
            \EndIf
            \textbf{end if}
            \EndFor
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
\end{document}
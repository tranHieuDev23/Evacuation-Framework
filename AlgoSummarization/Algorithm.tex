\section{Nội dung thuật toán}
    \subsection{Mô hình chung}
    Để tiện cho việc tính toán, ta coi các Indicator như là các Node 
    trong đồ thị, nối các Corridor được biểu diễn như các Edge nối giữa
    các Node. \\ 
    Ta áp dụng thuật toán Dijkstra để tìm đường đi có trọng số nhỏ nhất 
    của mối node tới exitNode- lối ra của tòa nhà. Ta đưa ra hàm tính 
    trọng số của một cạnh như sau: 
    \begin{equation}
        F(edge, density) =   
    \end{equation}

    Dưới đây là các đặc tính của lớp Node và Edge. \\ 
    \textbf{Node}: 
    \begin{itemize}
        \item \textit{next}: đỉnh được lựa chọn là hướng đi đến.
        \item \textit{nextEdge}: cạnh được lựa chọn là hướng đi đến.
        \item \textit{adjacences}: Danh sách struct gồm có:
        \begin{itemize}
            \item \textit{node}: đỉnh kề
            \item \textit{edge}: cạnh kề
            \item \textit{passingWeight}: trọng số của path mà đi qua đỉnh kề 
            \item \textit{reaching}: đỉnh tới được sau t(s) mà đi qua đỉnh 
            kề
        \end{itemize}    
        \item \textit{weight}: trọng số của đường đi tới root.
        \item \textit{nComingPeople}: số người sẽ đến sau t(s).
        \item \textit{tReachedNode}: đỉnh sẽ tới được sau t(s).
        \item \textit{tComingNodes}: danh sách đỉnh tới được sau t(s).
        \item \textit{label}: nhãn của đỉnh.
    \end{itemize}
    \textbf{Edge}
    \begin{itemize}
        \item \textit{to}: đỉnh tới.
        \item \textit{Length, Width, Trustness}: các thông số.
        \item \textit{nPeople}: số người trên cạnh.
        \item \textit{density}: mật độ.
        \item \textit{weight}: trọng số của cạnh.
    \end{itemize}
    \begin{algorithm}
    \caption{Algorithm caption}
    \label{alg:algorithm-label}
    \textbf{Input:} Đồ thị có trọng số ứng với các Indicator và Node\\
    \textbf{Output:} Đường đi ngắn nhất từ root đến mọi đỉnh trong đồ thị\\
    heap: cấu trúc heap min với phần tử là các đỉnh và so sánh dựa 
    trên weight.
    \begin{algorithmic}[1]
        \em
    \Procedure{Main Algorithm}{}
        \State heap.push(root)
        \State root.label $\gets$ true
        \While{$heap.size > 0$}
        \State $u \gets heap.pop()$
        \State u.label = true
        \State s $\gets$ u.tReachedNode
        \State s.nComingPeople $\gets$ s.nComingPeople + u.nextEdge.nPeople
        \State s.tComingNodes $\gets$ u
        \State \textbf{UpdateComingNode}(s)
        \For{v \textbf{in} u.adjacences \textbf{and} v.node.label = true}
        \State \textbf{UpdateComingPeople}(v.edge)
        \EndFor
        \For{v \textbf{in} u.adjacences \textbf{and} v.node.label = false} 
        \State s = \textbf{FindCrossNode}(v.node, v.edge)
        \State s.nComingPeople $\gets$ s.nComingPeople + v.edge.nPeople
        \State w1 $\gets$ \textbf{CalculateWeight}(u, s, v.edge.nPeople)
        \State w2 $\gets$ \textbf{CalculateWeight}(s, root, s.nComingPeople)
        \State newW $\gets$ v.edge.weight + w1 + w2
        \State ad \textbf{in} v.node.adjacences \textbf{which} ad.node = u
        \State ad.edgeWeight $\gets$ newW
        \State ad.reachedNode $\gets$ s
        \If{newW < v.node.weight}
        \State v.node.weight $\gets$ newW
        \State v.node.next $\gets$ u 
        \State v.node.tReachedNode $\gets$ s
        \State heap.push(v.node)
        \EndIf
        \State \textbf{end if}
        \State s.nComingPeople $\gets$ s.nComingPeople - E[v.node,u].nPeople
        \EndFor
        \textbf{end for}
        \EndWhile
        \textbf{end while}
    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{UpdateComingPeople}
        \textbf{Input}:Edge edge, Node node \\ 
        Cạnh nằm giữa hai đỉnh đã được gán nhãn và chưa được cập nhật. \\
        \textbf{Output:}: Cập nhật số người ở cạnh đó cho đỉnh nó tới được sau t(s)

        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \em
            \State s $\gets$ \textbf{FindCrossNode}(node, edge)
            \State s.nComingPeople $\gets$ s.nComingPeople + edge.nPeople
            \State \textbf{UpdateComingNode}(s)
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
    
    \begin{algorithm}
        \caption{FindCrossNode}
        \textbf{Input}: \textit{Node} node, \textit{Edge} edge\\
        \textbf{Output}: Trả lại đỉnh xa nhất trên đường đi ngắn nhất của u mà v 
        đi tới được trong thời gian t.
        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \em
            \State sumWeight $\gets$ $v_{tb}*t$ 
            \State nPeople $\gets$ edge.nPeople
            \State from $\gets$ node
            \While{sumWeight > 0}
            \State sumWeight $\gets$ sumWeight - \textbf{GetWeight}(edge, nPeople)
            \State from $\gets$ edge.to
            \State edge $\gets$ from.nextEdge
            \If{from = root} break
            \EndIf
            \EndWhile 
            \textbf{end while} \\
            \Return from
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{CalculateWeight}
        \textbf{Input}: \textit{Node} u, \textit{Node} s, int nPeople \\
        \textbf{Output}: Trả lại trọng số của quãng đường đi từ u tới s với 
        nPeople người đi.
        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \em
            \State weight $\gets$ 0
            \While{u \textbf{!=} s}
            \State edge $\gets$ u.nextEdge
            \State u $\gets$ u.next
            \State density $\gets$ \textbf{GetDensity}(edge, nPeople)
            \State weight $\gets$ weight + L * \textbf{F}(edge.Trustness, density)
            \EndWhile
            \Return weight
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{UpdateComingNode}
        \textbf{Input}: \textit{Node} s \\ 
        \textbf{Output}: Cập nhật lại trọng số của các Node mà sẽ tới được s
        trong thời gian t những vẫn chưa được gán nhãn.
        \begin{algorithmic}
            \Procedure{My Procedure}{}
            \For{u \textbf{in} s.tComingNodes \textbf{and} u.label = false}
            \State v \textbf{in} u.adjacences \textbf{which} v.reaching = s
            \State w1 $\gets$ \textbf{CalculateWeight}(v.node, s, v.edge.nPeople)
            \State w2 $\gets$ \textbf{CalculateWeight}(s, root, s.nComingPeople)
            \State v.passingWeight $\gets$ v.edge.weight + w1 + w2
            \State \textbf{GetNextNode}(u)
            \State heap.Rebuild(u)
            \EndFor
            \textbf{end for}
            \EndProcedure

            \Procedure{GetNextNode}{u}
            \Comment{Đặt lại đỉnh kề tốt nhất cho u}
            \For{v \textbf{in} u.adjacences \textbf{and} v.node.label = true}
            \If{v.edgeWeight < u.weight}
            \State u.weight = v.edgeWeight
            \State u.next = v.node
            \State u.tReachedNode = v.reachedNode \\
            \EndIf
            \textbf{end if}
            \EndFor
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}